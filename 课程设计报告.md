# 公司人事管理系统<br>课程设计报告

 无07 陈宇阳 2020010816

---

## 系统需求分析

公司人事管理系统是为了管理一家公司的人事情况。招聘了一位新员工，我们需要在人员记录表中添加此人员的信息；炒了一位员工的鱿鱼，我们需要在人员记录表中将他删去；老板有可能想不起来了员工的信息，我们需要把全部员工信息显示给老板看；公司开生日会需要了解员工生日，我们需要能在人员记录表中查询具体人员信息；某位员工喜得升迁，我们要在人员记录表中修改他的信息。

因此设计公司人事管理系统，以实现对公司人事信息的增添、删除、显示、查询与修改功能。

计划此系统以菜单方式工作，即系统会显示一个带有方法选择指引的主界面，用户可以自由选择菜单中的方法进行操作。主界面经过精心的艺术设计，还带有保姆级的温馨提示。同时，系统提供的方法每一步都有清晰明了的指引，以确保用户不会进行错误的操作，力求为每一位用户提供极致的人事管理体验。

>  注：本系统原本为公司人事管理系统，但由于本人对公司的人事继承和派生关系不甚了解，故改为学校的人事管理系统。



## 总体设计

### 系统功能分析

本系统提供对学校内人事的储存和管理操作，包含了

* 无类别人员
* 本科生
* 研究生
* 教职人员
* 助教

五个人员类别，每个类别均储存其姓名、编号、性别、生日等基本信息，再根据具体类别的不同分别储存其特有的信息，如专业、部门等。在储存信息的基础上，系统提供了增、删、改、查等功能，现详述如下：

1. **增加人员**

   用户可以往储存文件 `学校人员记录表格.txt` 中添加人员信息。从键盘中输入以选择想要添加的人员类别，根据提示输入对应姓名、学号等人员信息，输入完成后系统会以字符串流的方式将信息储存起来，未来也可以从文件中重新读出此信息。

2. **删除人员**

   用户可以在储存文件 `学校人员记录表格.txt` 中删除人员信息。从键盘中输入想要删除的人员的姓名或者学号，系统会自动遍历整个储存文件寻找匹配的人员，若找到，则询问是否要删除。用户确认后，系统将在储存文件的原位置永久删除该人员的信息。如果有同名或者同学号的人员，则仅删除用户确认删除的第一位人员，其他人员可以通过再次进行删除操作来删除。删除操作不会改变储存文件中其他信息的排布形式。

3. **显示全部**

   用户可以通过此方法读取储存文件 `学校人员记录表格.txt` 中的全部人员信息并显示出来。此显示并不是单纯地输出字符串，而是有对应信息的标签和不同人员的分离。一目了然，方便后续的增删改查操作。

4. **查询人员**

   用户可以在储存文件 `学校人员记录表格.txt` 中查询人员信息。从键盘中输入想要查询的人员的姓名或者学号，系统会自动遍历整个储存文件寻找匹配的人员，若找到，则显示出该人员的信息。如果有同名或者同学号的人员，系统会把所有匹配的信息全部显示出来并在最后显示找到匹配信息的数目。

5. **修改人员**

   用户可以在储存文件 `学校人员记录表格.txt` 中修改人员信息。从键盘中输入想要修改的人员的姓名或者学号，系统会自动遍历整个储存文件寻找匹配的人员，若找到，则显示出该人员的信息，并询问是否需要修改。 若用户确认修改，则可以选择需要录入的新人员类型并输入对应的信息。系统将在储存文件原来的位置处储存新输入的信息。如果有同名或者同学号的人员，则仅修改用户确认修改的第一位人员，其他人员可以通过再次进行修改操作来修改。其他信息的顺序排布不会被打乱。

   

### 功能模块图



![image-20210720133623878](C:\Users\Yu.Y\AppData\Roaming\Typora\typora-user-images\image-20210720133623878.png)

---

## 详细设计

	### 类结构图



<img src="C:\Users\Yu.Y\AppData\Roaming\Typora\typora-user-images\image-20210720135116620.png" alt="image-20210720135116620" style="zoom:67%;" />

### 工作流程图

<img src="C:\Users\Yu.Y\AppData\Roaming\Typora\typora-user-images\image-20210720135935722.png" alt="image-20210720135935722" style="zoom:67%;" />

​                                                                                               👆 同时也是工作流程图

### 人员结构·UML类图



![image-20210721142429742](C:\Users\Yu.Y\AppData\Roaming\Typora\typora-user-images\image-20210721142429742.png)





### 其他类型

此外，为了贯彻落实C++面向对象的程序设计思想，我还在系统中声明了两个类。

一个是 `FileErr` 类，计划在储存文件打开或读取发生异常时调用，报告错误信息并跳过该段的执行，以免发生系统崩溃的情况。

<img src="C:\Users\Yu.Y\AppData\Roaming\Typora\typora-user-images\image-20210721142921844.png" alt="image-20210721142921844" style="zoom:67%;" />



另一个是`conductor` 类，把与用户进行交互的六个函数封装起来，对于头文件的调用也全部在这个类中进行。限制了用户进行其他的操作，并造成了整个main函数只有一个对象的金刚芭比的假象。（

<img src="C:\Users\Yu.Y\AppData\Roaming\Typora\typora-user-images\image-20210721143611715.png" alt="image-20210721143611715" style="zoom:67%;" />





## 系统调试

​	摸着石头过河，我在写bug和debug的良性循环中逐步完善着自己的程序，以下是一些在调试过程中遇到的典型的问题：

* `char*`类操作困难

  我一开始写程序记录信息是使用`char*`的，随着后来对字符串信息调用和修改需求逐渐增多，我不得不改为`string`类。所以`char*`，这一来自C语言的历史遗留有什么不好呢？

  首先，它只是一个指针类型，没有构造函数，在你给它分配空间以前，它就是空悬的，不能直接给一个`char*`赋值。那给它分配多少空间呢？在用户输入以前，这是无法确定的，你只能给它分配一个足够大的空间，以免用户输入的信息过长导致内存溢出，这显然是低效而不优美的方法。

  `char* `所引发的浅拷贝问题。浅拷贝是含有指针变量的数据成员的类所面临的共同问题，在复制构造函数中，你不能对`char*`直接进行`operator=`的操作因为它们将指向同一空间，若其中一个对象被析构，另一个对象的信息也会丢失。解决方法只有在函数体中给指针重新`new`一个空间，并给空间赋值。但这又很可能导致你忘记了`delete`而引发内存泄漏问题，还要记得delete要写成`delete []char`。本系统所声明的每一个对象都需要多个字符串来记录信息，需要注意多少个`char*`的生成和删除？

  `char*`的相等判断困难。在对人员信息的查询和修改函数中，都需要进行已有信息和输入信息的匹配。两个`char*`指针比较显然不等，因为这个比较的是它们的地址。两个`*pt`比较也不等，因为虽然字符串相同，但空间大小不同（字符串后面还有`\0`）。根本没法实现匹配。最后我的解决方法是`if (strcmp(p,number)==0|| strcmp(p, name) == 0)`用字符串比较函数。

  使用`char*`导致的困难还有很多，在此不作一一列举。我也明白`char*`是`string`的基础，弄懂基础很重要，但是。。。使用`string`的确能省略很多麻烦，没有分配空间的痛苦，没有传值传址的困难，于是我就屈服了。



* `fstream`操作不甚熟悉

  把一个`object `的信息写入文件是简单轻快的。困难在于如何把文件中的信息读取出来并重新生成一个`object`。这涉及一个编码和解码的问题，我需要按照一定的顺序记录信息，再按照相同的顺序解析信息。最困难的地方在于空格和换行符的不可见性。在读取完一段字符串后计算机怎样才能知道”*这个`object`的信息已经足够了，下一串字符串是下一位人员的信息* “呢？我最后采用的方法是在保存信息的时候为每一条信息增加开始符和结束符，开始符是`<数字>+<人员类型>`的格式，告诉机器现在读取的是一个什么人员的信息，从而确定每一段字符串的含义，结束符是`#\n`,告诉计算机这个人员的信息已经读完，并应该换行了。引入结束符`#`提高了程序运行的效率，因为当计算机发现人员信息不匹配时，可以直接调用函数`ifile.getline(str,1024,'#')`来快速经过这一行而不生成没有意义的对象。

  `C++`为什么要把读文件和写文件、读模式和写模式分开？是为了增加程序的自由度，保证文件内容的安全吗？反正我的文件因此变得不怎么安全了。在读和写的不断切换中，某次程序的突然崩溃就直接导致了文件信息的全部丢失。从此我也养成了文件备份的好习惯。在`modify_mode()`信息修改的模式中，我需要先读入所有信息，进行信息匹配，再重新写上修改过后的信息。由于不同的人员类具有不同的信息编码格式，因此我在每一个人员类中都声明了其独有的`virtual void modify()`。虽然说程序莫名其妙就执行成功了，但我觉得我的`modify()`函数是十分不优美的，它接收了太多参数，既有`int`，也有`ofstream&`，这意味着它与主操作函数`modify_mode()`紧紧联系在了一起，而根本不可能作为一个函数接口被独立地调用，这不是一个封装好的类该有的样子。我甚至在`modify()`函数中进行了偷梁换柱：关闭了传进来的`ofstream& ofile`文件（写模式：`ios:trunc`），并以另一种写模式`ios::app`的方式重新打开它。这种操作无疑也是很危险的，但由于时间紧迫，且`modify()`函数与太多函数有关联，牵一发而动全身，故没有进行改善。算是一大遗憾吧。

  

* 虚函数 虚基类 抽象类 混淆

  此三者可谓`C++`多态性的强大实现工具。但对它们一知半解就无脑调用无疑会导致更多的痛苦。

  声明一个虚函数的目的是让派生类继承其接口以及缺省的行为。同名的接口通过虚函数可以实现部分内容的分离。当虚函数与类指针混合在一起时，可能会导致混乱，比如：基类指针指向派生类对象，调用的就是基类的函数；但如果是虚函数，调用的就是派生类的虚函数（当然，抽象类中若声明了相应的纯虚函数也是如此）

  作为一个基类，把析构函数声明为虚函数是有必要的。因为虚析构函数使得在删除指向子类对象的基类指针时可以调用子类的析构函数达到释放子类中堆内存的目的，从而防止内存泄漏。

  虚基类与虚函数不同，它是为了解决多重继承的问题，避免出现两份不同的基类拷贝。在定义有虚基类的派生类的时候一定要记得在构造函数的初始化列表中首先初始化虚基类！这是一个需要记住的点。

  抽象类跟它的名字一样，更是一个玄之又玄的东西。我最开始在抽象类中声明了`save()`和`modify()`两个纯虚函数接口，希望在`add_mode()`和`modify_mode()`中通过抽象类指针`abstract_human *pt = NULL` 然后 `pt = new <Class>()；pt->save();`这样的方法来统一地调用虚函数。结果编译过了，却在`delete pt;`的过程中触发了异常断点(`未加载wntdll`)。百思不得其解，只能找助教解决。这个bug一de就是半天，最后才知道抽象类`abstract_human()`需要定义一个虚的析构函数。因为`abstract_human()`是作为一个基类存在，如果其析构函数不是虚函数，`delete`的时候只会调用基类的析构函数，我在抽象类中压根就没有定义析构函数，也没有数据成员，于是就相当于什么都没有删除，自然会报错。

  我觉得可以被编译器检查出来的bug都不是什么问题，智能的VS系统已经明确指出了出问题的代码位置和问题。难以处理的是*未定义行为* ，现在大概明白这与内存空间、指针等问题有关。至于*触发断点* 的异常只见过一次（抽象类的析构函数），这也与内存泄漏、堆栈溢出有关。算是吃一堑，长一智。
  
  啊，C++真是博大精深。

## 测试结果分析

本程序的测试数据文件为`学校人员记录表格.txt`，测试情况如下。

* `学校人员记录表格.txt` 内容截图（此处姓名、编号只是胡乱编写，并没有任何含义，若有冒犯，请多见谅）

  <img src="C:\Users\Yu.Y\AppData\Roaming\Typora\typora-user-images\image-20210723140233753.png" alt="image-20210723140233753" style="zoom:67%;" />

* 打开程序，显示主界面。

  <img src="C:\Users\Yu.Y\AppData\Roaming\Typora\typora-user-images\image-20210723135749563.png" alt="image-20210723135749563" style="zoom:67%;" />

* 按“3” 显示文件内容。

  * 显示全部

  ![image-20210723140409272](C:\Users\Yu.Y\AppData\Roaming\Typora\typora-user-images\image-20210723140409272.png)

  * 按任意键返回主界面并清屏。

  <img src="C:\Users\Yu.Y\AppData\Roaming\Typora\typora-user-images\image-20210723140534998.png" alt="image-20210723140534998" style="zoom:67%;" />

* 按“1” 添加人员

  * 选择录入人员类别。

    <img src="C:\Users\Yu.Y\AppData\Roaming\Typora\typora-user-images\image-20210723140713099.png" alt="image-20210723140713099"  />

  * 助教最复杂，故选择“5” 作为示例。

    ![image-20210723140839528](C:\Users\Yu.Y\AppData\Roaming\Typora\typora-user-images\image-20210723140839528.png)

  * 按照提示逐行输入信息。

    ![image-20210723141040997](C:\Users\Yu.Y\AppData\Roaming\Typora\typora-user-images\image-20210723141040997.png)

    ![image-20210728231557923](C:\Users\Yu.Y\AppData\Roaming\Typora\typora-user-images\image-20210728231557923.png)

    如果输入的生日日期或者性别不合法，将被要求重新输入。

  * 显示了保存的格式并提示提示信息已经保存。我们打开储存文件看一下。大概确凿是已经保存。

    ![image-20210723141306849](C:\Users\Yu.Y\AppData\Roaming\Typora\typora-user-images\image-20210723141306849.png)

  * 返回主界面后再 按“3” 显示全部信息。可知确实已经保存。

    ![image-20210723141424091](C:\Users\Yu.Y\AppData\Roaming\Typora\typora-user-images\image-20210723141424091.png)

  

* 按“2”进行数据删除。【接下来只进行截图，不作过多文字阐释。】

  ![image-20210723141739344](C:\Users\Yu.Y\AppData\Roaming\Typora\typora-user-images\image-20210723141739344.png)

  ![image-20210723141814540](C:\Users\Yu.Y\AppData\Roaming\Typora\typora-user-images\image-20210723141814540.png)

  * 1.继续删除

    ![image-20210723141905899](C:\Users\Yu.Y\AppData\Roaming\Typora\typora-user-images\image-20210723141905899.png)

    * 先选择“N”

      ![image-20210723142014498](C:\Users\Yu.Y\AppData\Roaming\Typora\typora-user-images\image-20210723142014498.png)

    * 回到删除界面，这次输入学号。

      ![image-20210723142100811](C:\Users\Yu.Y\AppData\Roaming\Typora\typora-user-images\image-20210723142100811.png)

      

    * Yes！

      ![image-20210723142206103](C:\Users\Yu.Y\AppData\Roaming\Typora\typora-user-images\image-20210723142206103.png)

      对应的那一行被删除了。

    * 返回并显示全部。

      ![image-20210723142336732](C:\Users\Yu.Y\AppData\Roaming\Typora\typora-user-images\image-20210723142336732.png)

* 按“4” 数据查询

  ![image-20210723142527602](C:\Users\Yu.Y\AppData\Roaming\Typora\typora-user-images\image-20210723142527602.png)

  ![image-20210723142629437](C:\Users\Yu.Y\AppData\Roaming\Typora\typora-user-images\image-20210723142629437.png)

  ![image-20210723142713466](C:\Users\Yu.Y\AppData\Roaming\Typora\typora-user-images\image-20210723142713466.png)

  * 为方便演示，我给数据储存文件添加一条同名信息。

    ![image-20210723142939067](C:\Users\Yu.Y\AppData\Roaming\Typora\typora-user-images\image-20210723142939067.png)

  * 再检索。（同名/ 同学号）

    ![image-20210723143023675](C:\Users\Yu.Y\AppData\Roaming\Typora\typora-user-images\image-20210723143023675.png)

* 按“5” 数据修改

  * 确认要修改的人并进入修改模式。

  ![image-20210723143329071](C:\Users\Yu.Y\AppData\Roaming\Typora\typora-user-images\image-20210723143329071.png)

  * 改就完了。

    ![image-20210723143535086](C:\Users\Yu.Y\AppData\Roaming\Typora\typora-user-images\image-20210723143535086.png)

  * 显示全部 确认一下。

    ![image-20210723143619362](C:\Users\Yu.Y\AppData\Roaming\Typora\typora-user-images\image-20210723143619362.png)

    

    

* 很满意，遂按6退出程序。

  ![image-20210723143920557](C:\Users\Yu.Y\AppData\Roaming\Typora\typora-user-images\image-20210723143920557.png)

  

## 总结与展望

本系统的设计把我在这一年学习的程序设计知识全部融会贯通起来了，我对于C的指针类型，对于C++的抽象、封装、继承和多态有了更深入的理解，尤其是继承与多态。本系统各个模块的设计其实在黄永峰老师的作业中已经有了雏形，但是是非常粗糙的，完全没有体现C++面向对象的思想。后来便旧瓶装新酒，开始了这个系统的再次设计。

比较满意的地方：

* 贯彻落实面向对象思想，万物皆是类，异常是类，操作系统也是类。
* 提高了代码的专业程度和严谨程度。比如给每个类都定义了赋值运算符和复制构造函数；在构造函数中懂得活用初始化列表；重载了`operator<<`和`operator>>`使得代码更优雅且容易理解；懂得运用`inline`提升效率；运用`const` 保证封装性；在参数和返回值上正确选择传值或传址，等等。
* 学会了写头文件把接口与实现分离。提高了代码的可读性，后续的维护和优化也变得简单了。

有待提高的地方：

* 系统仅实现了记录功能，没有开发统计功能。我以为我这种编码储存方式很难实现统计功能。如果能引入**链表**进行储存，在每一个对象中储存一个`next`指针指向一个同类对象，应该可以方便地实现统计功能。
* 函数接口的复用性不强，以至于很多地方代码重复。像是`delete_mode()`、`search_mode()` 和 `modify_mode()` 都包含数据检索的过程，但它们的数据检索代码都是各自独立的，因为其中一些字符的显示和运算逻辑有所不同。如果可以写出一个函数，根据检索到的不同值传回一个对应的`object`的话，应该是可以复用的，但我不会。
* `modify()`函数，纯粹的面向过程设计。写得很差，根本不配被称为接口。
* 算法逻辑有待提高，我觉得像修改并储存这样的过程的实现还是太粗重了。

希望以后多读书，多写代码，写出更高质量的代码。

## 附录1： 源程序清单

### 主要人员结构

#### 抽象类 abstract_human.h

```c++
//抽象类一般不包含数据成员，只提供接口
#include<string>
#include<fstream>
#pragma once

#ifndef abstract_human_H
#define abstract_human_H

using namespace std;

class abstract_human
{
public:
	virtual ~abstract_human() {};  //史诗级debug的结果！抽象类里面要加虚析构函数才可以delete！
	virtual void save() = 0;
	virtual void modify(int target, int i, int line_num, string* line, std::ofstream& file) = 0;
};

#endif // !abstract_human_H

```

#### people.h

```c++
#pragma once
#include"abstract_human.h"
#include"date.h"
#include<iostream>
#include<string>
#include<fstream>

//People 类的声明
//People 为基本人员类，私有数据成员较少，可作为后续类别派生的基类。

#ifndef PEOPLE_H
#define PEOPLE_H
class People:virtual public abstract_human
{
public:
	People(string nm , string num , string sx , int yy, int mm, int dd);
	People();
	People(const People& rhs);
	virtual ~People();
	People& operator= (const People& rhs);
	friend std::ostream& operator<<(std::ostream&, const People&);
	virtual void save();
	virtual void modify(int target, int i, int line_num, string* line,std::ofstream& file);
protected:
	string name;
	string number;
	string sex;
	Date birthday;
};
#endif // !PEOPLE_H

```

#### people.cpp

```c++
#include"people.h"
#include"FileErr.h"

#include<iostream>
#include<strstream>
#include<fstream>
#include<string>
#include<iomanip>
#include<conio.h>
#pragma warning(disable : 4996)
using namespace std;

//有参构造函数
//参数：姓名、学号、性别
//生成一个基本人员类对象
People::People(string nm, string num, string sx, int yy, int mm, int dd) :
	name(nm), number(num),sex(sx), birthday(yy,mm,dd)
{ }

//无参构造函数
//参数：None
//通过调用无参构造函数使client可以直接在操作系统中构造想要的对象。
People::People()
{
	cout << "请输入以下信息：" << endl;
	cout << "姓名："; cin >> name;
	cout << "编号："; cin >> number;
	cout << "性别："; cin >> sex;
	while (sex != "男" && sex != "女")
	{
		cout << "性别不合法！请输入“男”或“女”\n 性别：" << endl;
		cin >> sex;
	}
	cout << "生日："; cin >> birthday;
}

//析构函数
//参数：none
//释放该对象的内存并打印提示
People::~People() {}

//复制构造函数
//参数：一个常对象的引用 const People&rhs
//通过一个已有对象对另一个已有对象赋值
//return：复制后的新对象
People::People(const People& rhs)
{
	name = rhs.name;
	number = rhs.number;
	sex = rhs.sex;
	birthday = rhs.birthday;
};
 
//赋值运算符的重载
//参数：一个常对象的引用 const People&rhs
//通过一个已有对象对另一个已有对象赋值
//return：通过传址方式返回新的原有对象
People& People::operator= (const People& rhs)
{
	if (this == &rhs) return *this;
	name = rhs.name;
	number = rhs.number;
	sex = rhs.sex;
	birthday = rhs.birthday;
	return *this;
};

void People::save()
{
	
	char c[80];
	ostrstream strout(c, 80);
	try
	{
		ofstream ofile("学校人员记录表格.txt", ios::app);
		if (!ofile) throw (FileErr());
		else
		{
			strout << "1无类别 " << this->name << setw(8)<<" " <<this->number <<" " << this->sex << " "<< this->birthday << " " << "#" << endl;
			strout << ends;
			cout << c;//调试
			ofile << c;
			cout << "信息保存成功。" << endl;
			ofile.close();
		}
	}
	catch (FileErr E)
	{
		E.reasonopen();
		cout << "按任意键返回。" << endl;
		char c=getch();
	}
	
}

//流输出运算符重载
//参数：output：输出流、rhs：目标People object
//return：ostream& 返回输出流本身。
ostream& operator<<(ostream& output, const People&rhs)
{
	output << "姓名：" << rhs.name << endl;
	output << "编号：" << rhs.number << endl;
	output << "性别：" << rhs.sex << endl;
	output << "生日：" << rhs.birthday << endl;
	return output;
}

//修改对象保存函数
//参数：target：用来储存对象所在文件行数/ i：目标文件所在的行数 / line_num:总行数 / line：string类数组指针 分别储存了文件中每一行的字符串 / ofile:输出流文件
//在modifymode()中调用此函数，可以把修改过的对象存入txt文件中。
// 用于保存，并非用于修改。
//return: 无

void People::modify(int target, int i, int line_num,string* line ,ofstream& ofile)
{
	
	target = i;
	for (i = 0; i < line_num; i++)
	{
		if (i != target) ofile << *(line + i) << endl;
		else
		{
			ofile.close();
			this->save();
			ofile.open("学校人员记录表格.txt", ios::app);
			continue;
		}
	}
	cout << "新信息已保存。" << endl;
}
```

#### student.h

```c++
#pragma once
#include"people.h"
#include"date.h"

#ifndef STUDENT_H
#define STUDENT_H

#include<String>
#include<iostream>
#include<fstream>
using namespace std;

class Student : virtual public People
{
public:
	Student(string nm, string num, string sx, int yy, int mm, int dd, string clno);
	Student();
	Student(const Student& rhs);
	virtual ~Student();
	Student& operator= (const Student& rhs);
	friend ostream& operator<<(ostream&, const Student& rhs);
	virtual void save();
	virtual void modify(int target, int i, int line_num, string* line, std::ofstream& file);
protected:
	string classno;
};
#endif
```

#### student.cpp

```c++
#include "student.h"//实现文件中需要把基类的头文件也Import了
#include"FileErr.h"

#include<iostream>
#include<fstream>
#include<strstream>
#include<iomanip>
#include<conio.h>
#include<string>

#pragma warning(disable:4996)

//有参构造函数
//参数：姓名、学号、性别、班别
//生成一个学生类对象
Student::Student(string nm, string num, string sx, int yy, int mm, int dd, string clno) :
	People(nm, num, sx, yy, mm, dd), classno(clno)
{}
Student::~Student() {}

//无参构造函数
//参数：None
//通过调用无参构造函数使client可以直接在操作系统中构造想要的对象。
Student::Student() :People()
{
	cout << "班别："; cin >> classno;
}

//复制构造函数
Student::Student(const Student& rhs) :People(rhs)
{
	classno = rhs.classno;
};

//赋值运算符的重载
//参数：一个常对象的引用 const People&rhs
//通过一个已有对象对另一个已有对象赋值
//return：通过传址方式返回新的原有对象
Student& Student::operator= (const Student& rhs)
{
	if (this == &rhs) return *this;
	name = rhs.name;
	number = rhs.number;
	sex = rhs.sex;
	birthday = rhs.birthday;
	classno = rhs.classno;
	return *this;
}

//流输出运算符重载
//参数：output：输出流、rhs：目标People object
//return：ostream& 返回输出流本身。
ostream& operator<<(ostream& output, const Student& rhs)
{
	output << "姓名：" << rhs.name << endl;
	output << "学号：" << rhs.number << endl;
	output << "性别：" << rhs.sex << endl;
	output << "生日：" << rhs.birthday << endl;
	output << "班别：" << rhs.classno << endl;
	return output;
}

void Student::save()
{
	char c[80];
	ostrstream strout(c, 80);
	try
	{
		ofstream ofile("学校人员记录表格.txt", ios::app);
		if (!ofile) throw (FileErr());
		else
		{
			strout << "2学生 " << this->name << setw(8) << " " << this->number << " " << this->sex << " " << this->birthday << " " << this->classno << " " << "#" << endl;
			strout << ends;
			cout << c;//调试
			ofile << c;
			cout << "信息保存成功。" << endl;
			ofile.close();
		}
	}
	catch (FileErr E)
	{
		E.reasonopen();
		cout << "按任意键返回。" << endl;
		char c = getch();
	}
}
//修改对象保存函数
//参数：target：用来储存对象所在文件行数/ i：目标文件所在的行数 / line_num:总行数 / line：string类数组指针 分别储存了文件中每一行的字符串 / ofile:输出流文件
//在modifymode()中调用此函数，可以把修改过的对象存入txt文件中。
// 用于保存，并非用于修改。
//return: 无
void Student::modify(int target, int i, int line_num, string* line, ofstream& ofile)
{
	target = i;
	for (i = 0; i < line_num; i++)
	{
		if (i != target) ofile << *(line + i) << endl;
		else
		{
			ofile.close();
			this->save();
			ofile.open("学校人员记录表格.txt", ios::app);
			continue;
		}
	}
	cout << "新信息已保存。" << endl;
}
```

#### graduate.h

```c++
#pragma once
#include"student.h"
#include"date.h"

#ifndef Graduate_H
#define Graduate_H

#include<String>
#include<iostream>
#include<fstream>
using namespace std;

class Graduate :  public Student
{
public:
	Graduate(string nm, string num, string sx, int yy, int mm, int dd, string clno, string sub);
	Graduate();
	Graduate(const Graduate& rhs);
	virtual ~Graduate();
	Graduate& operator= (const Graduate& rhs);
	friend ostream& operator<<(ostream&, const Graduate& rhs);
	virtual void save();
	virtual void modify(int target, int i, int line_num, string* line, std::ofstream& file);
protected:
	string subject;
};


#endif


```

#### graduate.cpp

```c++
#include "Graduate.h"//实现文件中需要把基类的头文件也Import了
#include"FileErr.h"

#include<iostream>
#include<fstream>
#include<strstream>
#include<iomanip>
#include<conio.h>
#include<string>

#pragma warning(disable:4996)

//有参构造函数
//参数：姓名、学号、性别、班别
//生成一个研究生类对象
Graduate::Graduate(string nm, string num, string sx, int yy, int mm, int dd, string clno, string sub) :
	People(nm,num,sx,yy,mm,dd),Student(nm, num, sx, yy, mm, dd,clno), subject(sub)
{}
Graduate::~Graduate() {}

//无参构造函数
//参数：None
//通过调用无参构造函数使client可以直接在操作系统中构造想要的对象。
Graduate::Graduate() :People(),Student()
{
	cout << "专业："; cin >> subject;
}

//复制构造函数
Graduate::Graduate(const Graduate& rhs) :Student(rhs)
{
	subject = rhs.subject;
};

//赋值运算符的重载
//参数：一个常对象的引用 const Student&rhs
//通过一个已有对象对另一个已有对象赋值
//return：通过传址方式返回新的原有对象
Graduate& Graduate::operator= (const Graduate& rhs)
{
	if (this == &rhs) return *this;
	name = rhs.name;
	number = rhs.number;
	sex = rhs.sex;
	birthday = rhs.birthday;
	classno = rhs.classno;
	subject = rhs.subject;
	return *this;
}

//流输出运算符重载
//参数：output：输出流、rhs：目标Student object
//return：ostream& 返回输出流本身。
ostream& operator<<(ostream& output, const Graduate& rhs)
{
	output << "姓名：" << rhs.name << endl;
	output << "学号：" << rhs.number << endl;
	output << "性别：" << rhs.sex << endl;
	output << "生日：" << rhs.birthday << endl;
	output << "班别：" << rhs.classno << endl;
	output << "学科：" << rhs.subject << endl;
	return output;
}
//对象保存函数
//参数：无
//在函数体中把此对象的各个信息储存到文件“学校人事管理系统.txt”中
//return: 无

void Graduate::save()
{
	char c[80];
	ostrstream strout(c, 80);
	try
	{
		ofstream ofile("学校人员记录表格.txt", ios::app);
		if (!ofile) throw (FileErr());
		else
		{
			strout << "3研究生 " << this->name << setw(8) << " " << this->number << " " << this->sex << " " << this->birthday << " " << this->classno << " " << this->subject<<" "<<"#" << endl;
			strout << ends;
			cout << c;//调试
			ofile << c;
			cout << "信息保存成功。" << endl;
			ofile.close();
		}
	}
	catch (FileErr E)
	{
		E.reasonopen();
		cout << "按任意键返回。" << endl;
		char c = getch();
	}
}

//修改对象保存函数
//参数：target：用来储存对象所在文件行数/ i：目标文件所在的行数 / line_num:总行数 / line：string类数组指针 分别储存了文件中每一行的字符串 / ofile:输出流文件
//在modifymode()中调用此函数，可以把修改过的对象存入txt文件中。
// 用于保存，并非用于修改。
//return: 无

void Graduate::modify(int target, int i, int line_num, string* line, ofstream& ofile)
{
	target = i;
	for (i = 0; i < line_num; i++)
	{
		if (i != target) ofile << *(line + i) << endl;
		else
		{
			ofile.close();
			this->save();
			ofile.open("学校人员记录表格.txt", ios::app);
			continue;
		}
	}
	cout << "新信息已保存" << endl;
}
```

#### teacher.h

```c++
#pragma once
#include"people.h"
#include"date.h"
#include<iostream>
#include<string>
#include<fstream>

//Teacher 类的声明
//Teacher 为教职工类，由People类派生而来，具有职位（principal）和部门（department）的私有数据成员

#ifndef TEACHER_H
#define TEACHER_H
class Teacher :virtual public People
{
public:
	Teacher(string nm, string num, string sx, int yy, int mm, int dd, string department, string principal);
	Teacher();
	Teacher(const Teacher& rhs);
	virtual ~Teacher();
	Teacher& operator= (const Teacher& rhs);
	friend std::ostream& operator<<(std::ostream&, const Teacher&);
	virtual void save();
	virtual void modify(int target, int i, int line_num, string* line, std::ofstream& file);
protected:
	string department;
	string principal;
};



#endif // !TEACHER_H
```

#### teacher.cpp

```c++
#include "teacher.h"//实现文件中需要把基类的头文件也Import了
#include"FileErr.h"

#include<iostream>
#include<fstream>
#include<strstream>
#include<iomanip>
#include<conio.h>
#include<string>

#pragma warning(disable:4996)

//有参构造函数
//参数：姓名、学号、性别、职位、部门
//生成一个教职人员类对象
Teacher::Teacher(string nm, string num, string sx, int yy, int mm, int dd, string dpmt, string prcpl) :
	People(nm, num, sx, yy, mm, dd), department(dpmt),principal(prcpl){ }

//析构函数
Teacher::~Teacher() {  }

//无参构造函数
//参数：None
//通过调用无参构造函数使client可以直接在操作系统中构造想要的对象。
Teacher::Teacher() :People()
{
	cout << "部门："; cin >> department;
	cout << "职务："; cin >> principal;
}

//复制构造函数
Teacher::Teacher(const Teacher& rhs) :People(rhs)
{
	department = rhs.department;
	principal = rhs.principal;
};

//赋值运算符的重载
//参数：一个常对象的引用 const People&rhs
//通过一个已有对象对另一个已有对象赋值
//return：通过传址方式返回新的原有对象
Teacher& Teacher::operator= (const Teacher& rhs)
{
	if (this == &rhs) return *this;
	name = rhs.name;
	number = rhs.number;
	sex = rhs.sex;
	birthday = rhs.birthday;
	department = rhs.department;
	principal = rhs.principal;
	return *this;
}

//流输出运算符重载
//参数：output：输出流、rhs：目标People object
//return：ostream& 返回输出流本身。
ostream& operator<<(ostream& output, const Teacher& rhs)
{
	output << "姓名：" << rhs.name << endl;
	output << "学号：" << rhs.number << endl;
	output << "性别：" << rhs.sex << endl;
	output << "生日：" << rhs.birthday << endl;
	output << "部门：" << rhs.department << endl;
	output << "职务：" << rhs.principal << endl;
	return output;
}

void Teacher::save()
{
	char c[80];
	ostrstream strout(c, 80);
	try
	{
		ofstream ofile("学校人员记录表格.txt", ios::app);
		if (!ofile) throw (FileErr());
		else
		{
			strout << "4教职人员 " << this->name << setw(8) << " " << this->number << " " << this->sex << " " << this->birthday << " " << this->department << " "<<this->principal<<" " << "#" << endl;
			strout << ends;
			cout << c;//调试
			ofile << c;
			cout << "信息保存成功。" << endl;
			ofile.close();
		}
	}
	catch (FileErr E)
	{
		E.reasonopen();
		cout << "按任意键返回。" << endl;
		char c = getch();
	}
}
//修改对象保存函数
//参数：target：用来储存对象所在文件行数/ i：目标文件所在的行数 / line_num:总行数 / line：string类数组指针 分别储存了文件中每一行的字符串 / ofile:输出流文件
//在modifymode()中调用此函数，可以把修改过的对象存入txt文件中。
// 用于保存，并非用于修改。
//return: 无
void Teacher::modify(int target, int i, int line_num, string* line, std::ofstream& ofile)
{
	
	target = i;
	for (i = 0; i < line_num; i++)
	{
		if (i != target) ofile << *(line + i) << endl;
		else
		{
			ofile.close();
			this->save();
			ofile.open("学校人员记录表格.txt", ios::app);
			continue;
		}
	}
	cout << "新信息已保存。" << endl;
}
```

#### TA.h

```c++
#pragma once
#include"teacher.h"
#include"graduate.h"
#include"date.h"

#ifndef TA_H
#define TA_H

#include<String>
#include<iostream>
#include<fstream>
using namespace std;

class TA : public Graduate, public Teacher
{
public:
	TA(string nm, string num, string sx, int yy, int mm, int dd, string clno, string subj, string department, string principal);
	TA();
	TA(const TA& rhs);
	~TA();
	TA& operator= (const TA& rhs);
	friend ostream& operator<<(ostream&, const TA& rhs);
	virtual void save();
	virtual void modify(int target, int i, int line_num, string* line, std::ofstream& file);
};

#endif

```

#### TA.cpp

```c++
#include "TA.h"//实现文件中需要把基类的头文件也Import了
#include"FileErr.h"

#include<iostream>
#include<fstream>
#include<strstream>
#include<iomanip>
#include<conio.h>
#include<string>

#pragma warning(disable:4996)

//有参构造函数
//参数：姓名、学号、性别、班别
//生成一个研究生类对象
TA::TA(string nm, string num, string sx, int yy, int mm, int dd, string clno, string sub, string dpmt, string prin) :
	People(nm, num, sx, yy, mm, dd), Graduate(nm, num, sx,yy,mm,dd,clno,sub), Teacher(nm,num,sx,yy,mm,dd,dpmt, prin)
{}

TA::~TA() {}

//无参构造函数
//参数：None
//通过调用无参构造函数使client可以直接在操作系统中构造想要的对象。
TA::TA() :People(),Graduate(),Teacher()
{ }

//复制构造函数
TA::TA(const TA& rhs) :People(rhs),Graduate(rhs),Teacher(rhs)
{ };

//赋值运算符的重载
//参数：一个常对象的引用 const Graduate&rhs
//通过一个已有对象对另一个已有对象赋值
//return：通过传址方式返回新的原有对象
TA& TA::operator= (const TA& rhs)
{
	if (this == &rhs) return *this;
	name = rhs.name;
	number = rhs.number;
	sex = rhs.sex;
	birthday = rhs.birthday;
	classno = rhs.classno;
	subject = rhs.subject;
	department = rhs.department;
	principal = rhs.principal;
	return *this;
}

//流输出运算符重载
//参数：output：输出流、rhs：目标Graduate object
//return：ostream& 返回输出流本身。
ostream& operator<<(ostream& output, const TA& rhs)
{
	output << "姓名：" << rhs.name << endl;
	output << "学号：" << rhs.number << endl;
	output << "性别：" << rhs.sex << endl;
	output << "生日：" << rhs.birthday << endl;
	output << "班别：" << rhs.classno << endl;
	output << "科目：" << rhs.subject << endl;
	output << "部门：" << rhs.department << endl;
	output << "职务：" << rhs.principal << endl;
	return output;
}
//对象保存函数
//参数：无
//在函数体中把此对象的各个信息储存到文件“学校人事管理系统.txt”中
//return: 无

void TA::save()
{
	char c[80];
	ostrstream strout(c, 80);
	try
	{
		ofstream ofile("学校人员记录表格.txt", ios::app);
		if (!ofile) throw (FileErr());
		else
		{
			strout << "5助教 " << this->name << setw(8) << " " << this->number << " " 
				<< this->sex << " " << this->birthday << " " << this->classno << " "
				<< this->subject << " " << this->department << " " << this->principal << " " << "#" << endl;
			strout << ends;
			cout << c;//调试
			ofile << c;
			cout << "信息保存成功。" << endl;
			ofile.close();
		}
	}
	catch (FileErr E)
	{
		E.reasonopen();
		cout << "按任意键返回。" << endl;
		char c = getch();
	}
}

//修改对象保存函数
//参数：target：用来储存对象所在文件行数/ i：目标文件所在的行数 / line_num:总行数 / line：string类数组指针 分别储存了文件中每一行的字符串 / ofile:输出流文件
//在modifymode()中调用此函数，可以把修改过的对象存入txt文件中。
// 用于保存，并非用于修改。
//return: 无

void TA::modify(int target, int i, int line_num, string* line, ofstream& ofile)
{
	target = i;
	for (i = 0; i < line_num; i++)
	{
		if (i != target) ofile << *(line + i) << endl;
		else
		{
			ofile.close();
			this->save();
			ofile.open("学校人员记录表格.txt", ios::app);
			continue;
		}
	}
	cout << "新信息已保存。" << endl;
}
```



### 其他类

#### 日期类 date.h

```c++
//日期类的声明
//重载了输入流运算符和输出流运算符，到时候方便一起输出
#pragma once
#include<iostream>

#ifndef DATE_H
#define DATE_H

class Date
{
public:
	Date(int yy=0, int mm=0, int dd=0);
	~Date();
	int getyear() const;
	int getmonth() const;
	int getday() const;
	Date& operator = (const Date& rhs);
	friend std::ostream& operator<<(std::ostream&, const Date& rhs);
	friend std::istream& operator>>(std::istream&, Date& rhs);
private:
	int year;
	int month;
	int day;
};

#endif //!DATE_H
```

#### date.cpp

```c++
#include"date.h"
#include <iostream>
using namespace std;

bool date_find(int year, int month, int day) //输入年月日 判断日期是否合法
{
	if (year < 1901 || year >2021 || month < 1 || month > 12 || day < 1 || day > 31) return false;
	else if (month == 4 || month == 6 || month == 9 || month == 11)
	{
		if (day == 31) return false;
		else return true;
	}
	else if (month == 2)
	{
		if (year % 4 == 0)  //闰年
		{
			if (day > 29) return false;
			else return true;
		}
		else
		{
			if (day > 28) return false;
			else return true;
		}
	}
	else return true;

}


Date::Date(int yy, int mm, int dd)
{
	int a, b, c;
	a = yy;
	b = mm;
	c = dd;
	while (!date_find(a, b, c))
	{
		cout << "日期不合法！请重新输入（年/月/日）" << endl;
		cin >> a >> b >> c;
	}
	year = a;
	month = b;
	day = c;
}


Date::~Date() { }

int Date::getyear() const { return year; }
int Date::getmonth() const { return month; }
int Date::getday() const { return day; }

Date& Date::operator=(const Date& rhs)
{
	if (this == &rhs) return *this;
	year = rhs.year;
	month = rhs.month;
	day = rhs.day;
	return *this;
}

ostream& operator <<(ostream& output, const Date& rhs)
{
	output << rhs.year << " ";
	output << rhs.month << " ";
	output << rhs.day;
	return output;
}

istream& operator >>(istream& input, Date& rhs)
{
	input >> rhs.year >> rhs.month >> rhs.day;
	while (!date_find(rhs.getyear(), rhs.getmonth(), rhs.getday()))
	{
		cout << "日期不合法！请重新输入（年/月/日）：" << endl;
		input.clear();
		input >> rhs.year >> rhs.month >> rhs.day;
	}
	return input;
}


```

#### 文件异常类 FileErr.h

```c++
//操作错误类，声明报错的函数

#pragma once
#ifndef FILEERR_H
#define FILEERR_H

class FileErr
{
public:

	int reasonopen() const;
	int reasonread() const;
};

#endif // !FILEERR_H

```

#### FileErr.cpp

```c++
#include"FileErr.h"
#include<iostream>
using namespace std;

int FileErr::reasonopen() const
{
	cout << "文件打开失败！" << endl;
	return 0;
}

int FileErr::reasonread() const
{
	cout << "文件读写错误！" << endl;
	return 0;
}
```

#### 操作系统 conductor.h

```c++
#pragma once
#include"date.h"
#include"abstract_human.h"
#include"people.h"
#include"student.h"
#include"graduate.h"
#include"teacher.h"
#include"TA.h"
#include"FileErr.h"


#include<iostream>
#include<string>
#include<fstream>
#include<strstream>
#include<iomanip>
#include<conio.h>
#pragma warning(disable:4996)
using namespace std;

#ifndef CONDUCTOR_H
#define CONDUCTOR_H
//读取文件中一行的信息并打印出来。
void getinfo_line(ifstream& ifile)
{
	char genre[10];
	
	string name, number, sex, classno, subject,department ,principal;
	Date birthday;
	ifile >> genre >> name >> number >> sex >> birthday;
	switch (genre[0] - 48)
	{
	case 1:
	{
	People* p;
	p = new People(name, number, sex, birthday.getyear(), birthday.getmonth(), birthday.getday());
	cout << *p;
	delete p; }break;
	case 2:
	{ifile >> classno;

	Student* s = new Student(name, number, sex, birthday.getyear(), birthday.getmonth(), birthday.getday(), classno);
	cout << *s;
	delete s; }break;
	case 3:
	{ifile >> classno >> subject;
	Graduate* g;
	g = new Graduate(name, number, sex, birthday.getyear(), birthday.getmonth(), birthday.getday(), classno, subject);
	cout << *g;
	delete g; }break;
	
	case 4:
	{ifile >> department >> principal;
	Teacher* t;
	t = new Teacher(name, number, sex, birthday.getyear(), birthday.getmonth(), birthday.getday(), department, principal);
	cout << *t;
	delete t; }break;

	case 5:
	{ifile >>classno>>subject >>department >> principal;
	TA* ta;
	ta = new TA(name, number, sex, birthday.getyear(), birthday.getmonth(), birthday.getday(), classno, subject, department, principal);
	cout << *ta;
	delete ta; }break;
	}
}

//读取文件中一行的信息并判定是否与所需查找的信息相匹配，若匹配则打印信息，若否，则什么都不干。
void search_line(ifstream& ifile,string info, int& flag)
{
	string genre, name, number, sex, classno,subject,department,principal;
	Date birthday;
	ifile >> genre >> name >> number >> sex >> birthday;
	if (name == info || number == info)
	{
		cout << "===========" << flag << "===========" << endl;
		switch (genre[0] - 48)
		{
		case 1:
		{
			People* p;
			p = new People(name, number, sex, birthday.getyear(), birthday.getmonth(), birthday.getday());
			cout << *p;
			delete p; }break;
		case 2:
		{ifile >> classno;
		Student* s;
		s = new Student(name, number, sex, birthday.getyear(), birthday.getmonth(), birthday.getday(), classno);
		cout << *s;
		delete s; }break;
		case 3:
		{ifile >> classno >> subject;
		Graduate* g;
		g = new Graduate(name, number, sex, birthday.getyear(), birthday.getmonth(), birthday.getday(), classno, subject);
		cout << *g;
		delete g; }break;
		case 4:
		{ifile >> department>>principal;
		Teacher* t;
		t = new Teacher(name, number, sex, birthday.getyear(), birthday.getmonth(), birthday.getday(), department,principal);
		cout << *t;
		delete t; }break;
		case 5:
		{ifile >> classno >> subject>>department>>principal;
		TA* ta;
		ta = new TA(name, number, sex, birthday.getyear(), birthday.getmonth(), birthday.getday(), classno, subject, department, principal);
		cout << *ta;
		delete ta; }break;
		}
		flag ++;
	}

}
//有参搜索匹配人员信息。
int search_all(string info)
{
	cout << "开始查找" << endl;
	try
	{
		int flag = 0;
		ifstream ifile("学校人员记录表格.txt");
		if (!ifile) throw(FileErr());
		else
		{
			char str[1024];
			while (!ifile.eof() && ifile.tellg() != -1)
			{

				search_line(ifile, info, flag);
				cout << "指针位置：" << ifile.tellg() << endl;
				ifile.getline(str, 1024, '#');//跳过这一行，读到标准字符。

			}
			ifile.close();
			if (flag >= 1) cout << "共查找到以上" << flag << "个信息。" << endl;
			else cout << "未查找到相关信息！" << endl;
			return flag;

		}

	}
	catch (FileErr E)
	{
		E.reasonopen();
		cout << "按任意键返回。" << endl;
		char c = getch();
		return 0;
	}
	return 0;
}


//以下为在mainpage页面会向用户显示的接口。
class conductor
{
public:
	~conductor(){ cout << "感谢您的使用，再见。" << endl; }
	void mainpage()
	{
		system("cls");  //清屏函数
		cout.width(30);
		cout.fill('+');//输入符号只能用单引号
		cout.setf(ios::left);
		cout << " " << endl;

		cout.width(27);
		cout.fill(' ');
		cout.setf(ios::right);
		cout << "青花瓷大学人事管理系统" << endl;

		cout << " ";
		cout.width(29);
		cout.setf(ios::left);
		cout.fill('+');
		cout << "" << endl;


		cout.width(32);
		cout.fill('#');//输入符号只能用单引号
		cout << "" << endl << endl;

		cout.width(18);
		cout.fill(' ');
		cout.setf(ios::right);
		cout << "主菜单" << endl;
		cout.width(21);
		cout << "1.数据录入" << endl;
		cout.width(21);
		cout << "2.数据删除" << endl;
		cout.width(21);
		cout << "3.显示全部" << endl;
		cout.width(21);
		cout << "4.数据查询" << endl;
		cout.width(21);
		cout << "5.数据修改" << endl;
		cout.width(21);
		cout << "6.退出程序" << endl;
		cout.width(24);
		cout << "请选择序号(1-6)" << endl;
		cout << " ";
		cout.width(30);
		cout.setf(ios::left);
		cout.fill('+');
		cout << "" << endl;
		cout<<"\n\n\n欢迎使用【青花瓷大学人事管理系统】\n"
			<<"注意：切勿在程序操作途中突然退出程序，可能导致严重的数据丢失问题。退出程序请使用系统提供的接口。\n"<<endl;
		button();
		
		}
	void button()
		{
			char input = getch();
			switch (input - 48)
			{
			case 1: add_mode(); break;
			case 2: delete_mode(); break;
			case 3: show_mode(); break;
			case 4: search_mode(); break;
			case 5: modify_mode(); break;
			case 6: exit_mode(); break;
			default: {
				cout << "错误的输入，请重试:" << endl;
				button();
			}
		}

	}
private:
	//往文件中添加人员信息的接口。
	void add_mode()
	{
		char flag;
		cout << "请输入想录入人员的类别。" << endl;
		cout << "1.无类别 2.学生 3.研究生 4.教职人员 5.助教" << endl;
		flag = getch();
		abstract_human * pt = NULL;
		switch (flag - 48)
		{
		case 1: { cout << "录入模式：无类别" << endl; pt = new People(); }break;
		case 2: { cout << "录入模式：学生" << endl;  pt = new Student();}break;
		case 3: { cout << "录入模式：研究生" << endl; pt = new Graduate(); }break;
		case 4: { cout << "录入模式：教职人员" << endl; pt = new Teacher(); }break;
		case 5: { cout << "录入模式：助教" << endl; pt = new TA(); }break;
		default: cout << "输入字符有误，请重新输入！" << endl;
		}
		pt->save();
		delete pt;
		cout << "1.继续添加\t2.返回主界面" << endl;
		char button = getch();
		if (button == '1') add_mode();
		else mainpage();

	}

	//搜索整个文件寻找匹配的信息（无参），若找到匹配的信息，逐条打印该信息。
	void search_mode()
	{
		cout << "开始查找..." << endl;
		try
		{
			string info;
			int flag = 1;
			cout << "请输入需要查找的姓名/学号：" << endl;
			cin >> info;
			ifstream ifile("学校人员记录表格.txt");
			if (!ifile) throw(FileErr());
			else
			{
				char str[1024];
				while (!ifile.eof() && ifile.tellg() != -1)
				{

					search_line(ifile, info, flag);
					ifile.getline(str, 1024, '#');//跳过这一行，读到标准字符。

				}
				ifile.close();
				if (flag > 1) cout << "=======================\n共查找到以上" << flag-1 << "个信息。" << endl;
				else cout << "=======================\n未查找到相关信息！" << endl;

			}

		}
		catch (FileErr E)
		{
			E.reasonopen();
			cout << "按任意键返回主界面。" << endl;
			char c = getch();
		}
		cout << "1.重新搜索\t2.返回主界面" << endl;
		char button = getch();
		if (button == '1') search_mode();
		else mainpage();
	}

	//修改人员信息的接口 输入待查找的信息，即可在文件原位置进行修改。
	void modify_mode()
	{
		char str[512];
		string info, * line;
		int line_num = -1, i, target = 0;//获取文件行数和目标文件所在的行数
		int genre = 0;
		int flag = 0;  //记录修改的信息数
		char button;
		char type;
		ifstream ifile;
		ofstream ofile;
		cout << "请输入需要修改的的姓名/学号：";
		cin >> info;
		try
		{
			ifile.open("学校人员记录表格.txt");
			if (!ifile) throw(2);
			else
			{
				while (!ifile.eof())
				{
					ifile.getline(str, 1024, '#');
					line_num++;
				}
				line = new(string[line_num]);
				ifile.seekg(0);//使文件指针恢复到开头
				for (i = 0; i < line_num; i++)
				{
					getline(ifile, *(line + i)); //getline函数的另一种用法
				}
				ifile.seekg(ios::beg);//使文件指针恢复到开头
			//以上内容为使用字符串储存文件中已有的每一行信息。
				string genre, name, number, sex, classno, subject, dpmt, principal;
				Date birthday;
				for (i = 0; i < line_num && ifile.tellg() != -1; i++)
				{
					ifile >> genre >> name >> number >> sex >> birthday;
					cout << "读取进度：" << i + 1 << "/" << line_num << endl;
					if (name == info || number == info)
					{
						flag ++;
						cout << "在第" << i + 1 << "行处查找到信息如下：" << endl;
						switch (genre[0] - 48)   //判断指针类型
						{
						case 1:
						{People* p;
						p = new People(name, number, sex, birthday.getyear(), birthday.getmonth(), birthday.getday());
						cout << *p;
						delete p; }break;
						case 2:
						{ifile >> classno;
						Student* s;
						s = new Student(name, number, sex, birthday.getyear(), birthday.getmonth(), birthday.getday(), classno);
						cout << *s;
						delete s; }break;
						case 3:
						{ifile >> classno >> subject;
						Graduate* g;
						g = new Graduate(name, number, sex, birthday.getyear(), birthday.getmonth(), birthday.getday(), classno, subject);
						cout << *g;
						delete g; }break;
						case 4:
						{ifile >> dpmt >> principal;
						Teacher* t;
						t = new Teacher(name, number, sex, birthday.getyear(), birthday.getmonth(), birthday.getday(), dpmt, principal);
						cout << *t;
						delete t; }break;
						case 5:
						{ifile >> classno >> subject >> dpmt >> principal;
						TA* ta;
						ta = new TA(name, number, sex, birthday.getyear(), birthday.getmonth(), birthday.getday(), classno, subject, dpmt, principal);
						cout << *ta;
						delete ta; }break;
						}
						cout << "是否对此信息进行修改？(Y/N)" << endl;
						cin >> button;
						if (button == 'Y' || button == 'y')
						{
							cout << "请输入想要修改的人员类别：\n1.无类别  2.学生  3.研究生  4.教职人员  5.助教\n" ;
							cin >> type;
							abstract_human* pt = NULL;
							ifile.close();
							ofile.open("学校人员记录表格.txt", ios::trunc);
							switch (type - 48)
							{
							case 1: {
								cout << "修改模式：即将生成【1无类别】..." << endl;
								pt =new People();
							}break;
							case 2: {
								cout << "修改模式：即将生成【2学生】..." << endl;
								pt = new Student();
							}break;
							case 3: {
								cout << "修改模式：即将生成【3研究生】..." << endl;
								pt = new Graduate();
							}break;
							case 4: {
								cout << "修改模式：即将生成【4教职人员】..." << endl;
								pt = new Teacher();
							}break;
							case 5: {
								cout << "修改模式：即将生成【5助教】..." << endl;
								pt = new TA();
							}break;
							
							default: {cout << "错误的输入！请重试！" << endl;
							}
							}
							pt->modify(target, i, line_num, line, ofile);
							delete pt;
							ofile.close();
						}
					}
					ifile.getline(str, 1024, '#');
				}
				delete[]line;
			}


		}
		catch (int)
		{
			cout << "文件打开发生错误。" << endl;
			cout << "按任意键返回。" << endl;
			info[0] = getch();
			return;
		}
		catch (FileErr E)
		{
			E.reasonread();
			cout << "按任意键返回。" << endl;
			info[0] = getch();
			return;
		}
		if (flag == 0) cout << "未查找到相关信息！" << endl;
		cout << "1.继续修改\t2.返回主界面" << endl;
		button = getch();
		if (button == '1') modify_mode();
		else mainpage();

	}

	//删除人员信息的接口，输入待查找的信息，并在文件中删除该条信息。
	void delete_mode()
	{
		char str[512];
		string info, * line;
		int line_num = -1, i, target = -1;//获取文件行数和目标文件所在的行数
		int genre = 0;
		int flag = 0;  //记录查找的信息数
		char button;
		ifstream ifile;
		ofstream ofile;
		cout << "请输入需要删除的的姓名/学号：";
		cin >> info;
		try
		{
			ifile.open("学校人员记录表格.txt");
			if (!ifile) throw(2);
			else
			{
				while (!ifile.eof())
				{
					ifile.getline(str, 1024, '#');
					line_num++;
				}
				line = new(string[line_num]);
				ifile.seekg(0);//使文件指针恢复到开头
				for (i = 0; i < line_num; i++)
				{
					getline(ifile, *(line + i));
				}
				ifile.seekg(0);//使文件指针恢复到开头
			//以上内容为使用字符串储存文件中已有的每一行信息。
				string genre, name, number, sex, classno, subject, dpmt, principal;
				Date birthday;
				for (i = 0; i < line_num && ifile.tellg() != -1; i++)
				{
					ifile >> genre >> name >> number >> sex >> birthday;
					cout << "读取进度：" << i + 1 << "/" << line_num << endl;
					if (name == info || number == info)
					{
						flag = 1;
						cout << "在第" << i + 1 << "行处查找到信息如下：" << endl;
						switch (genre[0] - 48)   //判断指针类型
						{
						case 1:
						{People* p;
						p = new People(name, number, sex, birthday.getyear(), birthday.getmonth(), birthday.getday());
						cout << *p;
						cout << "是否对此信息进行删除？(Y/N)" << endl;
						cin >> button;
						if (button == 'Y' || button == 'y')
						{
							target = i;
							ifile.close();
							ofile.open("学校人员记录表格.txt", ios::trunc);
						}
						delete p; }break;
						case 2:
						{ifile >> classno;
						Student* s;
						s = new Student(name, number, sex, birthday.getyear(), birthday.getmonth(), birthday.getday(), classno);
						cout << *s;
						cout << "是否对此信息进行删除？(Y/N)" << endl;
						cin >> button;
						if (button == 'Y' || button == 'y')
						{
							target = i;
							ifile.close();
							ofile.open("学校人员记录表格.txt", ios::trunc);
						} delete s; }break;
						case 3:
						{ifile >> classno >> subject;
						Graduate* g;
						g = new Graduate(name, number, sex, birthday.getyear(), birthday.getmonth(), birthday.getday(), classno, subject);
						cout << *g;
						cout << "是否对此信息进行删除？(Y/N)" << endl;
						cin >> button;
						if (button == 'Y' || button == 'y')
						{
							target = i;
							ifile.close();
							ofile.open("学校人员记录表格.txt", ios::trunc);
						} delete g; }break;
						case 4:
						{ifile >> dpmt >> principal;
						Teacher* t;
						t = new Teacher(name, number, sex, birthday.getyear(), birthday.getmonth(), birthday.getday(), dpmt, principal);
						cout << *t;
						cout << "是否对此信息进行删除？(Y/N)" << endl;
						cin >> button;
						if (button == 'Y' || button == 'y')
						{
							target = i;
							ifile.close();
							ofile.open("学校人员记录表格.txt", ios::trunc);
						} delete t; }break;
						case 5:
						{ifile >> classno >> subject >> dpmt >> principal;
						TA* ta;
						ta = new TA(name, number, sex, birthday.getyear(), birthday.getmonth(), birthday.getday(), classno, subject, dpmt, principal);
						cout << *ta;
						cout << "是否对此信息进行删除？(Y/N)" << endl;
						cin >> button;
						if (button == 'Y' || button == 'y')
						{
							target = i;
							ifile.close();
							ofile.open("学校人员记录表格.txt", ios::trunc);
						} delete ta; }break;
						}
					}
					ifile.getline(str, 1024, '#');
					if (target != -1)
					{
						for (i = 0; i < line_num; i++)
						{
							if (i != target)
							{
								ofile << *(line + i) << endl;
								cout << *(line + i) << endl;
							}
							else {
								cout << "删除：" << *(line + i) << endl;
							}
						}
						ofile.close();
						cout << "删除操作成功！" << endl;
					}
				}
				delete[]line;
			}
			
		}
		catch (int)
		{
			cout << "文件打开发生错误。" << endl;
			cout << "按任意键返回。" << endl;
			info[0] = getch();
			return;
		}
		catch (FileErr E)
		{
			E.reasonread();
			cout << "按任意键返回。" << endl;
			info[0] = getch();
			return;
		}
		if (flag == 0) cout << "未查找到相关信息！" << endl;
		cout << "信息已遍历完成。\n1.继续删除\t2.返回主界面" << endl;
		button = getch();
		if (button == '1') delete_mode();
		else mainpage();
	}

	//显示信息接口，读取整个文件中的信息并打印出来。
	void show_mode()

	{
		int num = 1;
		int count = 0;
		cout << "开始提取文件信息。。。" << endl;
		try
		{
			ifstream ifile("学校人员记录表格.txt");
			if (!ifile) throw(FileErr());
			else
			{
				char str[1024];
				while (!ifile.eof() && ifile.tellg() != -1)
				{
					ifile.getline(str, 1024, '#');
					count++;
				}
				ifile.seekg(ios::beg);
				for (num; num< count;num++)
				{
					cout << "==========="<<num<<"===========" << endl;
					getinfo_line(ifile);
					ifile.getline(str, 1024, '#');//跳过这一行，读到标准字符。
				}
				ifile.close();
				cout << "=======================\n信息已全部显示！\n按任意键返回主界面。" << endl;
				char t = getch();
				mainpage();

			}

		}
		catch (FileErr E)
		{
			E.reasonopen();
			cout << "按任意键返回。" << endl;
			char c = getch();
		}
		
	}
	
	//显示感谢使用界面，退出程序。
	void exit_mode()
	{
		return;
	}

};




#endif // !CONDUCTOR_H


```

### main.cpp

```c++
#include"conductor.h"
int main()
{
	conductor Init;
	Init.mainpage();
	return 0;
} //金刚芭比本比
```

---

## 附录2：评分表

![image-20210723154445357](C:\Users\Yu.Y\AppData\Roaming\Typora\typora-user-images\image-20210723154445357.png)

